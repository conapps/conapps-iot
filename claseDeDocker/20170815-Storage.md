[<-- Volver](https://github.com/conapps/conapps-iot/blob/master/claseDeDocker/20170803-Imagenes.md) |
[Siguiente -->](https://github.com/conapps/conapps-iot/blob/master/claseDeDocker/20170807-Networking.md) |

## Storage
---

### Espacio en disco ocupado por un contenedor

Si ejecutamos

```bash
$ docker ps -s
CONTAINER ID        IMAGE                  COMMAND             CREATED             STATUS              PORTS                              NAMES               SIZE
f667d89cc276        ismaa10/nodejs-image   "bash"              19 hours ago        Up 19 hours         0.0.0.0:3000->3000/tcp, 8080/tcp   test                994kB (virtual 271MB)
```

vamos a ver que en la columna ```SIZE``` aparecen dos valores, el primero hace referencia al tamaño de la capa read-write de ese contenedor en particular y el ```virtual size``` que hace referencia al tamaño de la imagen a partir de la cual se generó el contenedor, esto es, todas las capas read-only.

Ambos valores sumados constituyen el espacio total en disco que ocupa un contenedor.
Algunas consideraciones importantes a tener en cuenta a la hora de estimar cuanto espacio ocupan los contenedores:

- En escenarios donde tengo varios contenedores derivados de la misma imágen, tengo que tener el cuenta de sumar el ```virtual size``` una única vez.
- Es posible que dos imagenes distintas compartan algunas capas, por lo que, en este escenario, si corremos dos contenedores, uno derivado de cada imagen, tampoco sería correcto sumar los ```virtual size``` de ambos.
- Además de su capa read-write, los contenedores pueden escribir datos en volúmenes externos. En tal caso este espacio no figura en la salida del comando ```docker ps -s```


### Funcionamiento de los drivers mas comúnes (aufs, overlay y overlay2)

Las lecturas y escrituras al filesystem que se genera para los contenedores a partir de las capas read-only y read-write, se realizan mediante algún _storage driver_. Para el caso de _Ubuntu_, el driver por defecto es _aufs_, sin embargo, el comportamiento que describiremos a continuación vale también para _overlay_ y _overlay2_.

Cada vez que un contedor quiere modificar un archivo de su filesystem, primero busca dicho archivo en las capas read-only, comenzando por la capa superior, avanzando hacia abajo una capa a la vez. Al encontrar el archivo, detiene la búsqueda y realiza una copia del mismo en la capa superior (read-write). De ahora en adelante, cada vez que quiera acceder a este archivo, el contenedor no tendrá acceso a la copia original, sino que se usará siempre la copia de la capa superior.

Este comportamiento se repite también en la generación de imágenes, donde cada vez que una capa superior modifica un archivo, realiza una copia del mismo invalidando las copias que puedan existir en capas inferiores.

### Alternativas para la persistencia de datos

#### Capa read-write del contenedor.
Es posible guardar la información de forma persistente en la capa read-write de cada contenedor, sin embargo esto tiene varias desventajas:

- Los datos se perderán al borrar el contenedor.
- Los datos generados no se pueden exportar fácilmente fuera de la máquina _host_.
- La escritura a la capa read-write de los contenedores se hace mediante un _storage driver_, lo que lo hace poco performante.

Por lo expuesto anteriormente, Docker ofrece tres alternativas para manejar la persistencia de datos en el host:

#### _bind mount_

En esta modalidad lo que se hace es montar un directorio de la máquina anfitrión (_host_), en un directorio del propio contenedor. Varios contenedores se pueden montar sobre el mismo directorio de la máquina _host_ y escribir y leer de forma simultánea.

Este método presenta como ventajas principales:

- Es mucho mas performante que guardar los archivos en la capa read-write de los contenedores dado que no utiliza el _storage driver_ de estos.
- Los datos persisten aún cuando los contenedores se eliminan.
- Varios contenedores pueden acceder y modificar los mismos archivos de forma simultánea.

#### _volumes_

Esta modalidad es igual que la anterior, con la diferencia que no es el usuario quien define el directorio a montar en la máquina _host_, sino que es el propio motor de Docker el que provee un directorio (transparente al usuario) en la máquina _host_ para manejar la persistencia de los datos. Salvo en algunas excepciones, este método es recomendado sobre el uso de _bind mount_ dado que presenta las siguientes ventajas:

- Permite desacoplar los comandos de Docker de la estructura de datos de la máquina _host_ donde este corre. Permitiendo migrar de un _host_ a otro con mínimo impacto.
- Mediante el uso de _volume drivers_ específicos se puede sincronizar los _volumes_ con proveedores de nube como AWS.

#### _tmpfs mount_

Los datos dentro de los _filesystems temporales_ son almacenados en la memoria RAM del host.
Este método es ideal cuando no se necesitan los datos mas allá del tiempo de vida del contenedor y es necesaria alta performance para la lectura/escritura de los mismos.

La imagen a continuación presenta un resumen de los tres tipos de persistencia de datos disponibles en el host:

![alt text](types-of-mounts.png "Tipos de persistencia de datos en el host")

### Volumes

> Es posible que quien haya trabajado con Docker previamente esté acostumbrado al uso de la opción ```*_-v_*``` para la configuración de volumenes.
> A partir de la versión 17.06 Docker recomienda utilizar la opción ```*_--mount_*```, por lo que en la presente guía seguiremos dicha recomendación y no haremos mención a las configuraciones mediante la opción ```*_-v_*```.

**Para crear un volumen:**
```bash
$ docker volume create nombre-del-volumen
```

**Para listar un volumen:**
```bash
$ docker volume ls
DRIVER              VOLUME NAME
local               nombre-del-volumen
```

**Para inspeccionar un volumen:**
```bash
$ docker volume inspect nombre-del-volumen
[
    {
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/nombre-del-volumen/_data",
        "Name": "nombre-del-volumen",
        "Options": {},
        "Scope": "local"
    }
]
```

**Para eliminar un volumen**
```bash
$ docker volume rm nombre-del-volumen
```

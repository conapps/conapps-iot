[<-- Volver](https://github.com/conapps/conapps-iot/blob/master/claseDeDocker/20170803-Imagenes.md) |
[Siguiente -->](https://github.com/conapps/conapps-iot/blob/master/claseDeDocker/20170807-Networking.md) |

## Storage
---

### Espacio en disco ocupado por un contenedor

Si ejecutamos

```bash
$ docker ps -s
CONTAINER ID        IMAGE                  COMMAND             CREATED             STATUS              PORTS                              NAMES               SIZE
f667d89cc276        ismaa10/nodejs-image   "bash"              19 hours ago        Up 19 hours         0.0.0.0:3000->3000/tcp, 8080/tcp   test                994kB (virtual 271MB)
```

vamos a ver que en la columna ```SIZE``` aparecen dos valores, el primero hace referencia al tamaño de la capa read-write de ese contenedor en particular y el ```virtual size``` que hace referencia al tamaño de la imagen a partir de la cual se generó el contenedor, esto es, todas las capas read-only.

Ambos valores sumados constituyen el espacio total en disco que ocupa un contenedor.
Algunas consideraciones importantes a tener en cuenta a la hora de estimar cuanto espacio ocupan los contenedores:

- En escenarios donde tengo mas de un contenedor derivados de la misma imágen, tengo que tener el cuenta de sumar el ```virtual size``` una única vez.
- Es posible que dos imagenes distintas compartan algunas capas, por lo que, en este escenario, si corremos dos contenedores, uno derivado de cada imagen, tampoco sería correcto sumar los ```virtual size``` de ambos.
- Además de su capa read-write, los contenedores pueden escribir datos en volúmenes externos. En tal caso este espacio no figura en la salida del comando ```docker ps -s```


### Funcionamiento de los drivers mas comúnes (aufs, overlay y overlay2)

Las lecturas y escrituras al filesystem que se genera para los contenedores a partir de las capas read-only y read-write, se realizan mediante algún _storage driver_. Para el caso de _Ubuntu_, el driver por defecto es _aufs_, sin embargo, el comportamiento que describiremos a continuación vale también para _overlay_ y _overlay2_.

Cada vez que un contedor quiere modificar un archivo de su filesystem, primero busca dicho archivo en las capas read-only, comenzando por la capa superior, avanzando hacia abajo una capa a la vez. Al encontrar el archivo, detiene la búsqueda y realiza una copia del mismo en la capa superior (read-write). De ahora en adelante, cada vez que quiera acceder a este archivo, el contenedor no tendrá acceso a la copia original, sino que se usará siempre la copia de la capa superior.

Este comportamiento se repite también en la generación de imágenes, donde cada vez que una capa superior modifica un archivo, realiza una copia del mismo invalidando las copias que puedan existir en capas inferiores.

### Alternativas para la persistencia de datos

Es posible guardar la información de forma persistente en la capa read-write de cada contenedor, sin embargo este tiene varias desventajas:

- Los datos se perderán al borrar el contenedor.
- Los datos generados no se pueden exportar fácilmente fuera de la máquina _host_.
- La escritura a la capa read-write de los contenedores se hace mediante un _storage driver_, lo que lo hace poco performante.

Por lo expuesto anteriormente, Docker ofrece tres alternativas para manejar la persistencia de datos:

#### _bind mount_

En esta modalidad lo que se hace es montar un directorio de la máquina anfitrión (_host_), en un directorio del propio contenedor. Varios contenedores se pueden montar sobre el mismo directorio de la máquina _host_ y escribir y leer de forma simultánea.

Este método presenta como ventajas principales:

- Es mucho mas performante que guardar los archivos en la capa read-write de los contenedores dado que no utiliza el _storage driver_ de estos.
- Los datos persisten aún cuando los contenedores se eliminan.
- Varios contenedores pueden acceder y modificar los mismos archivos de forma simultánea.

#### _volumes_

Esta modalidad es igual que la anterior, con la diferencia que no es el usuario quien define el directorio a montar en la máquina _host_, sino que es el propio motor de Docker el que provee un directorio (transparente al usuario) en la máquina _host_ para manejar la persistencia de los datos. Salvo en algunas excepciones, este método es recomendado sobre el uso de _bind mount_ dado que presenta las siguientes ventajas:

- Permite desacoplar los comandos de Docker de la estructura de datos de la máquina _host_ donde este corre. Permitiendo migrar de un _host_ a otro con mínimo impacto.
- Mediante el uso de _storage drivers_ específicos se puede sincronizar los _volumes_ con proveedores de nube como AWS.

#### _tmpfs mount_

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
